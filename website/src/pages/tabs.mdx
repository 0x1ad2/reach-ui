import SEO from "../components/SEO";
import { TOC, TOCList, TOCLink } from "../components/TOC";

<SEO title="Tabs" description="Accessible tabs component for React" />

# Tabs

<TOC>
  <TOCList>
    <TOCLink href="#tabs-1">Tabs</TOCLink>
    <TOCLink href="#tablist">TabList</TOCLink>
    <TOCLink href="#tab">Tab</TOCLink>
    <TOCLink href="#tabpanels">TabPanels</TOCLink>
    <TOCLink href="#tabpanel">TabPanel</TOCLink>
  </TOCList>
</TOC>

- Source: https://github.com/reach/reach-ui/tree/master/packages/tabs
- WAI-ARIA: https://www.w3.org/TR/wai-aria-practices-1.2/#tabpanel

An accessible tabs component.

The `Tab` and `TabPanel` elements are associated by their order in the tree. None of the components are empty wrappers, each is associated with a real DOM element in the document, giving you maximum control over styling and composition.

You can render any other elements you want inside of `Tabs`, but `TabList` should only render `Tab` elements, and `TabPanels` should only render `TabPanel` elements.

```jsx
// jsx-demo
function Example() {
  return (
    <Tabs>
      <TabList>
        <Tab>One</Tab>
        <Tab>Two</Tab>
        <Tab>Three</Tab>
      </TabList>

      <TabPanels>
        <TabPanel>
          <p>one!</p>
        </TabPanel>
        <TabPanel>
          <p>two!</p>
        </TabPanel>
        <TabPanel>
          <p>three!</p>
        </TabPanel>
      </TabPanels>
    </Tabs>
  );
}
```

[Check out the demos](#demos) for ideas on how to style and compose.

## Installation

From the command line in your project directory, run `npm install @reach/tabs` or `yarn add @reach/tabs`. Then import the components and styles that you need:

```bash
npm install @reach/tabs
# or
yarn add @reach/tabs
```

```js
import { Tabs, TabList, Tab, TabPanels, TabPanel } from "@reach/tabs";
import "@reach/tabs/styles.css";
```

## Component API

### Tabs

The parent component of the tab interface.

#### Tabs CSS Selectors

Please see the [styling guide](/styling).

```css
[data-reach-tabs] {
}
```

#### Tabs Props

| Prop                                             | Type                           | Required | Default        |
| ------------------------------------------------ | ------------------------------ | -------- | -------------- |
| [`as`](#tabs-as)                                 | `string` \| `Component`        | false    | `"div"`        |
| [`children`](#tabs-children)                     | `node`                         | true     |                |
| [`defaultIndex`](#tabs-defaultindex)             | `number`                       | false    |                |
| [`index`](#tabs-index)                           | `number`                       | false    |                |
| [`keyboardActivation`](#tabs-keyboardactivation) | `"auto"` \| `"manual"`         | false    | `"auto`        |
| [`onChange`](#tabs-onchange)                     | `func`                         | false    |                |
| [`orientation`](#tabs-orientation)               | `"horizontal"` \| `"vertical"` | false    | `"horizontal"` |
| [`div` props](#tabs-div-props)                   |                                | false    |                |

##### Tabs `as`

`as?: keyof JSX.IntrinsicElements | React.ComponentType`

Tabs will render a `div` unless you specify a different element.

##### Tabs `children`

`children: React.ReactNode`

Tabs expects `<TabList>` and `<TabPanels>` as children. The order doesn't matter, you can have tabs on the top or the bottom. In fact, you could have tabs on both the bottom and the top at the same time. You can have random elements inside as well.

```jsx
// jsx-demo
function Example() {
  return (
    <Tabs>
      <TabList>
        <Tab>Uno</Tab>
        <Tab>Dos</Tab>
      </TabList>

      <div>Random</div>

      <TabPanels>
        <TabPanel>Uno</TabPanel>
        <TabPanel>Dos</TabPanel>
      </TabPanels>

      <TabList>
        <Tab>Uno</Tab>
        <Tab>Dos</Tab>
      </TabList>
    </Tabs>
  );
}
```

##### Tabs `defaultIndex`

`defaultIndex?: number`

Starts the tabs at a specific index.

```jsx
// jsx-demo
function Example() {
  return (
    <Tabs defaultIndex={1}>
      <TabPanels>
        <TabPanel>
          <img src="https://placekitten.com/400/200" alt="A picture of a cat" />
        </TabPanel>
        <TabPanel>
          <img
            src="https://www.placecage.com/400/200"
            alt="A picture of Nicolas Cage"
          />
        </TabPanel>
      </TabPanels>
      <TabList>
        <Tab>Kitten</Tab>
        <Tab>Cage</Tab>
      </TabList>
    </Tabs>
  );
}
```

##### Tabs `index`

`index?: number`

Like form inputs, a tab's state can be controlled by the owner. Make sure to include an `onChange` as well, or else the tabs will not be interactive.

```jsx
// jsx-demo
function Example() {
  const [tabIndex, setTabIndex] = useState(0);

  const handleSliderChange = event => {
    setTabIndex(parseInt(event.target.value, 10));
  };

  const handleTabsChange = index => {
    setTabIndex(index);
  };

  return (
    <div>
      <input
        type="range"
        min="0"
        max="2"
        value={tabIndex}
        onChange={handleSliderChange}
      />

      <Tabs index={tabIndex} onChange={handleTabsChange}>
        <TabList>
          <Tab>One</Tab>
          <Tab>Two</Tab>
          <Tab>Three</Tab>
        </TabList>
        <TabPanels>
          <TabPanel>
            <p>Click the tabs or pull the slider around</p>
          </TabPanel>
          <TabPanel>
            <p>Yeah yeah. What's up?</p>
          </TabPanel>
          <TabPanel>
            <p>Oh, hello there.</p>
          </TabPanel>
        </TabPanels>
      </Tabs>
    </div>
  );
}
```

##### Tabs `keyboardActivation`

`keyboardActivation?: "auto" | "manual`

Describes the activation mode when navigating a tablist with a keyboard. When set to `"auto"`, a tab panel is activated automatically when a tab is highlighted using arrow keys. When set to `"manual"`, the user must activate the tab panel with either the <kbd>Spacebar</kbd> or <kbd>Enter</kbd> keys. Defaults to `"auto"`.

##### Tabs `onChange`

`onChange?: (index: number) => void`

Calls back with the tab index whenever the user changes tabs, allowing your app to synchronize with it.

```jsx
// jsx-demo
function Example() {
  const colors = ["firebrick", "goldenrod", "dodgerblue"];
  const [tabIndex, setTabIndex] = useState(0);
  const backgroundColor = colors[tabIndex];
  return (
    <Tabs
      onChange={index => setTabIndex(index)}
      style={{
        color: "white",
        background: backgroundColor,
      }}
    >
      <TabList>
        <Tab>Red</Tab>
        <Tab>Yellow</Tab>
        <Tab>Blue</Tab>
      </TabList>
      <TabPanels style={{ padding: 20 }}>
        <TabPanel>The Primary Colors</TabPanel>
        <TabPanel>Are 1, 2, 3</TabPanel>
        <TabPanel>Red, yellow and blue.</TabPanel>
      </TabPanels>
    </Tabs>
  );
}
```

##### Tabs `orientation`

`orientation?: "horizontal" | "vertical"`

Allows you to switch the orientation of the tabs relative to their tab panels. Defaults to `"horizontal"`.

Changing the orientation will change how the arrow keys navigate between tabs. Arrow key navigation should logically follow the order in which tabs appear on the screen. For screen reader users, the `aria-orientation` attribute provides the appropriate context to direct which keys should navigate to the next tab (this is provided automatically). As such, it's important to use this prop even if you have already styled your tabs for vertical layout.

```jsx
// jsx-demo
function Example() {
  // Try changing the orientation!
  return (
    <Tabs orientation="vertical">
      <TabList>
        <Tab>One</Tab>
        <Tab>Two</Tab>
        <Tab>Three</Tab>
      </TabList>

      <TabPanels>
        <TabPanel>
          <p>one!</p>
        </TabPanel>
        <TabPanel>
          <p>two!</p>
        </TabPanel>
        <TabPanel>
          <p>three!</p>
        </TabPanel>
      </TabPanels>
    </Tabs>
  );
}
```

If you're familiar with the relatively new specs for CSS logical properties, you'll know why we opt to use `start` and `end` rather than `left`, `right`, `top` or `bottom`. The `Tabs` component supports writing modes other than left-to-right, and `Tabs` will adapt keyboard controls to the match user's writing mode and the given orientation.

##### Tabs `div` props

All other props are passed to the underlying `div` (or another component passed to the `as` prop).

### TabList

The parent component of the tabs.

```jsx
<TabList>
  <Tab>Tacos</Tab>
  <Tab>Tortas</Tab>
</TabList>
```

#### TabList CSS Selectors

Please see the [styling guide](/styling).

```css
[data-reach-tab-list] {
}
```

#### TabList Props

| Prop                              | Type          | Required | Default |
| --------------------------------- | ------------- | -------- | ------- |
| [`as`](#tablist-as)               | ComponentType | false    | `"div"` |
| [`children`](#tablist-children)   | node          | true     |         |
| [`div` props](#tablist-div-props) |               |          |         |

##### TabList `children`

`children: React.ReactNode`

`TabList` expects multiple `Tab` elements as children.

```jsx
<TabList>
  <Tab>One</Tab>
  <Tab>Two</Tab>
</TabList>
```

But, you can also wrap `Tab` as long as you forward the props (because data is passed from `TabList` to `Tab` via React context).

```jsx
const RedTab = props => <Tab {...props} style={{ color: "red" }} />;

const TabPage = () => (
  <Tabs>
    <TabList>
      <RedTab>This is red</RedTab>
      <Tab>This is normal</Tab>
    </TabList>
    <TabPanels>
      <TabPanel>...</TabPanel>
      <TabPanel>...</TabPanel>
    </TabPanels>
  </Tabs>
);
```

##### TabList `as`

`as?: keyof JSX.IntrinsicElements | React.ComponentType`

Tabs will render a `div` unless you specify a different element.

```jsx
<TabList as={View} />
```

##### TabList `div` props

All other props are passed to the underlying `div` (or component passed to `as`).

### TabPanels

The parent component of the panels.

```jsx
<TabPanels>
  <TabPanel>My favorite</TabPanel>
  <TabPanel>My other favorite</TabPanel>
</TabPanels>
```

#### TabPanels CSS Selectors

Please see the [styling guide](/styling).

```css
[data-reach-tab-panels] {
}
```

#### TabPanels Props

| Prop                                | Type                    | Required | Default |
| ----------------------------------- | ----------------------- | -------- | ------- |
| [`as`](#tabpanels-as)               | `string` \| `Component` | false    | `"div"` |
| [`children`](#tabpanels-children)   | `node`                  | true     |         |
| [`div` props](#tabpanels-div-props) |                         |          |         |

##### TabPanels `as`

`as?: keyof JSX.IntrinsicElements | React.ComponentType`

Tabs will render a `div` unless you specify a different element.

```jsx
<TabPanels as={View} />
```

##### TabPanels `children`

`children: React.ReactNode`

`TabPanels` expects multiple `TabPanel` elements as children.

```jsx
<TabPanels>
  <TabPanel>One</TabPanel>
  <TabPanel>Two</TabPanel>
</TabPanels>
```

But, you can also wrap `TabPanel` as long as you forward the props (because data is passed from `TabPanels` to `TabPanel` via React context`).

```jsx
const BoldPanel = props => (
  <TabPanel {...props} style={{ fontWeight: "bold" }} />
);

const TabPage = () => (
  <Tabs>
    <TabList>
      <Tab>...</Tab>
      <Tab>...</Tab>
    </TabList>
    <TabPanels>
      <BoldPanel>...</BoldPanel>
      <TabPanel>...</TabPanel>
    </TabPanels>
  </Tabs>
);
```

##### TabPanels `div` props

All other props are passed to the underlying `div` (or component passed to `as`).

### Tab

The interactive element that changes the selected panel.

```jsx
<Tab>Coconut Korma</Tab>
```

#### Tab CSS Selectors

Please see the [styling guide](/styling).

```css
/* styles all tabs */
[data-reach-tab] {
}

/* styles only the selected tab */
[data-reach-tab][data-selected] {
}
```

#### Tab Props

| Prop                                | Type                    | Required | Default    |
| ----------------------------------- | ----------------------- | -------- | ---------- |
| [`as`](#tab-as)                     | `string` \| `Component` | false    | `"button"` |
| [`children`](#tab-children)         | node                    | true     |            |
| [`disabled`](#tab-disabled)         | boolean                 | false    | `false`    |
| [`button` props](#tab-button-props) |                         |          |            |

##### Tab `as`

`as?: keyof JSX.IntrinsicElements | React.ComponentType`

Tab will render a `button` unless you specify a different element.

```jsx
<Tab as={ReactNativeWebButton} />
```

##### Tab `children`

`children: React.ReactNode`

`Tab` can receive any type of children.

```jsx
<Tab>
  <HouseIcon /> Home
</Tab>
```

##### Tab `disabled`

`disabled?: boolean`

Disables a tab when true. Clicking will not work and keyboard navigation will skip over it.

```jsx
<Tab disabled />
```

##### Tab `button` props

All other props are passed to the underlying `button` (or component passed to `as`).

##### Tab `isSelected`

Because TabList needs to know the order of the children, we use `cloneElement` to pass state internally. If you want to know if a tab is active, you can wrap it, and then inspect clone props passed in.

> NOTE: We will deprecate this behavior in the future. We now prefer to use context to pass data down to descendants for `Tabs` for better composability. If you'd like your Tabs to be a bit more future proof, we suggest using a controlled `Tabs` component so that your app knows the state of your tabs.

```jsx
// jsx-demo
(() => {
  function CoolTab(props) {
    // `isSelected` comes from `TabList` cloning the `CoolTab`.
    const { isSelected, children } = props;

    // make sure to forward *all* props received from TabList
    return (
      <Tab {...props}>
        {isSelected ? "😎" : "😐"}
        {children}
      </Tab>
    );
  }

  return (
    <Tabs>
      <TabList>
        <CoolTab>One</CoolTab>
        <CoolTab>Two</CoolTab>
      </TabList>
      <TabPanels>
        <TabPanel>1</TabPanel>
        <TabPanel>2</TabPanel>
      </TabPanels>
    </Tabs>
  );
})();
```

### TabPanel

The panel that displays when it's corresponding tab is active.

```jsx
<TabPanel>
  <h2>The Best Food</h2>
  <p>The best food is either Mexican or Indian.</p>
</TabPanel>
```

#### TabPanel CSS Selectors

Please see the [styling guide](/styling).

```css
/* styles all tabs */
[data-reach-tab-panel] {
}
```

#### TabPanel Props

| Prop                               | Type                    | Required | Default |
| ---------------------------------- | ----------------------- | -------- | ------- |
| [`as`](#tabpanel-as)               | `string` \| `Component` | false    | `"div"` |
| [`children`](#tabpanel-children)   | `node`                  | false    |         |
| [`div` props](#tabpanel-div-props) |                         |          |         |

##### TabPanel `as`

`as?: keyof JSX.IntrinsicElements | React.ComponentType`

TabPanel will render a `div` unless you specify a different element.

```jsx
<Tab as={View} />
```

##### TabPanel `children`

`children?: React.ReactNode`

`TabPanel` can receive any type of children.

```jsx
<TabPanel>
  <h2>Whatever you want</h2>
  <p>In here</p>
</TabPanel>
```

##### TabPanel `div` props

All other props are passed to the underlying `div` (or component passed to `as`).

## Demos

These demos show off how you can add quite a bit of behavior to your Tabs interfaces.

### DataTabs

If you'd like to drive your tabs with data you can create a `DataTabs` component.

```jsx
// jsx-demo
(() => {
  function DataTabs({ data }) {
    return (
      <Tabs>
        <TabList>
          {data.map((tab, index) => (
            <Tab key={index}>{tab.label}</Tab>
          ))}
        </TabList>
        <TabPanels>
          {data.map((tab, index) => (
            <TabPanel key={index}>{tab.content}</TabPanel>
          ))}
        </TabPanels>
      </Tabs>
    );
  }

  // now if you have an array of data...
  const tabData = [
    { label: "Taco", content: "Perhaps the greatest dish ever invented." },
    {
      label: "Burrito",
      content:
        "Perhaps the greatest dish ever invented but bigger and with rice.",
    },
  ];

  // you can just pass it in:
  return <DataTabs data={tabData} />;
})();
```

### Animation

With a little composition we can animate the selected tab bar.

```jsx
// jsx-demo
(() => {
  const AnimatedContext = React.createContext();

  function AnimatedTabs(props) {
    // need to store the position of the selected Tab so we can
    // animate the bar to its position
    const [selectedRect, setSelectedRect] = useState(null);

    // need to measure the parent element so we can measure
    // the relative "left" for the bar
    const tabsRef = useRef();
    const tabsRect = useRect(tabsRef);

    // Put the function to change the positions on context so the
    // Tabs down the tree can easily access it
    return (
      <AnimatedContext.Provider value={setSelectedRect}>
        <Tabs
          {...props}
          ref={tabsRef}
          style={{ ...props.style, position: "relative" }}
        >
          {props.children[0]}

          {/* put the bar inbetween the TabList and TabPanels */}
          <div
            style={{
              position: "absolute",
              height: 2,
              background: props.color,
              marginTop: -2,

              // Here is the actual animation part, we use the
              // rect from the selected tab to set the styles of the bar
              transition: "all 300ms ease",
              left: selectedRect && selectedRect.left - tabsRect.left,
              width: selectedRect && selectedRect.width,
            }}
          />
          {props.children[1]}
        </Tabs>
      </AnimatedContext.Provider>
    );
  }

  function AnimatedTab(props) {
    const { isSelected } = props;

    // Each tab measures itself
    const ref = useRef();
    const rect = useRect(ref, isSelected);

    // and calls up to the parent when it becomes selected
    // we useLayoutEffect to avoid flicker
    const setSelectedRect = useContext(AnimatedContext);
    useLayoutEffect(() => {
      if (isSelected) setSelectedRect(rect);
    }, [isSelected, rect, setSelectedRect]);

    return (
      <Tab ref={ref} {...props} style={{ ...props.style, border: "none" }} />
    );
  }

  // And that's it! It's not a small amount of code, but it's not a ton
  // either, and it's all composed on top, instead of built in.
  return (
    <AnimatedTabs color="red" style={{ width: 400 }}>
      <TabList style={{ justifyContent: "space-around" }}>
        <AnimatedTab style={{ flex: 1 }}>The First</AnimatedTab>
        <AnimatedTab style={{ flex: 2 }}>This has longer text</AnimatedTab>
        <AnimatedTab style={{ flex: 1 }}>Three</AnimatedTab>
      </TabList>
      <TabPanels style={{ padding: 10 }}>
        <TabPanel>
          <p>Check it out! It's ~animated~</p>
        </TabPanel>
        <TabPanel>
          <p>Yeah yeah. What's up?</p>
        </TabPanel>
        <TabPanel>
          <p>Oh, hello there.</p>
        </TabPanel>
      </TabPanels>
    </AnimatedTabs>
  );
})();
```

### Keyboard Accessibility

| Key                                          | Action                                                                               |
| -------------------------------------------- | ------------------------------------------------------------------------------------ |
| <kbd>Enter</kbd> / <kbd>Spacebar</kbd>       | Sets the focused tab to `active` when `keyboardActivation` is set to `"manual"`.     |
| <kbd>ArrowUp</kbd> / <kbd>ArrowDown</kbd>    | Navigates between tabs when `orientation` is `"vertical"`. See below more details.   |
| <kbd>ArrowLeft</kbd> / <kbd>ArrowRight</kbd> | Navigates between tabs when `orientation` is `"horizontal"`. See below more details. |
| <kbd>Home</kbd> / <kbd>PageUp</kbd>          | Navigates to the last tab in the `TabList`.                                          |
| <kbd>End</kbd> / <kbd>PageDown</kbd>         | Navigates to the first tab in the `TabList`.                                         |

When focused on the active tab, an arrow key should move focus to its corresponding active tab panel depending on where it appears relative to the tab. For example, in horizontal tabs where the `TabList` appears above the `TabPanels`, the <kbd>ArrowDown</kbd> key focuses the active tab panel. For vertical tabs with in the same order, <kbd>ArrowRight</kbd> moves focus for left-to-right reading mode and <kbd>ArrowLeft</kbd> for right-to-left reading mode. The opposite arrow key for either orientation is used when the rendered DOM order is reversed.

For this reason, it is recommended that you always reverse the order of the `TabList` and `TabPanels` components if you want to change their visual representation. This keeps keyboard navigation logical and keyboard users happy!
